import { keccak_256 } from "@noble/hashes/sha3";
import { etc, getPublicKey } from "@noble/secp256k1";
import { actionSorter, isAbstractEthersSigner, isAbstractEthersV5Signer, isAbstractViemWalletClient, isAbstractWindowEthereum, isValidPrivateKey, signL1Action, signUserSignedAction, userSignedActionEip712Types, } from "../signing/mod.js";
import { ExchangeClient, } from "./exchange.js";
/**
 * Multi-signature exchange client for interacting with the Hyperliquid API.
 * @typeParam T The transport used to connect to the Hyperliquid API.
 * @typeParam S Array of wallets where the first wallet acts as the leader.
 */
export class MultiSignClient extends ExchangeClient {
    multiSignAddress;
    signers;
    /**
     * Initialises a new multi-signature client instance.
     * @param args - The parameters for the multi-signature client.
     *
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport();
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     * ```
     */
    constructor(args) {
        super({ ...args, wallet: args.signers[0] });
        this.multiSignAddress = args.multiSignAddress;
        this.signers = args.signers;
        Object.defineProperty(this, "wallet", {
            get() {
                return this.signers[0];
            },
            set(value) {
                this.signers[0] = value;
            },
            enumerable: true,
            configurable: true,
        });
    }
    /**
     * Approve an agent to sign on behalf of the master account.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#approve-an-api-wallet
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.approveAgent({ agentAddress: "0x...", agentName: "..." });
     * ```
     */
    async approveAgent(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.approveAgent({
            type: "approveAgent",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        if (action.agentName === "")
            action.agentName = null;
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Approve a maximum fee rate for a builder.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#approve-a-builder-fee
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.approveBuilderFee({ maxFeeRate: "0.01%", builder: "0x..." });
     * ```
     */
    async approveBuilderFee(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.approveBuilderFee({
            type: "approveBuilderFee",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Modify multiple orders.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful variant of {@link OrderResponse} without error statuses.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.batchModify({
     *   modifies: [
     *     {
     *       oid: 123,
     *       order: {
     *         a: 0,
     *         b: true,
     *         p: "31000",
     *         s: "0.2",
     *         r: false,
     *         t: { limit: { tif: "Gtc" } },
     *       },
     *     },
     *   ],
     * });
     * ```
     */
    async batchModify(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.batchModify({ type: "batchModify", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Cancel order(s).
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful variant of {@link CancelResponse} without error statuses.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.cancel({
     *   cancels: [
     *     { a: 0, o: 123 },
     *   ],
     * });
     * ```
     */
    async cancel(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.cancel({ type: "cancel", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Cancel order(s) by cloid.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful variant of {@link CancelResponse} without error statuses.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.cancelByCloid({
     *   cancels: [
     *     { asset: 0, cloid: "0x..." },
     *   ],
     * });
     * ```
     */
    async cancelByCloid(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.cancelByCloid({ type: "cancelByCloid", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Transfer native token from the user's spot account into staking for delegating to validators.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#deposit-into-staking
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.cDeposit({ wei: 1 * 1e8 });
     * ```
     */
    async cDeposit(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.cDeposit({
            type: "cDeposit",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Claim rewards from referral program.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.claimRewards();
     * ```
     */
    async claimRewards(...[signal]) {
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.claimRewards({ type: "claimRewards" });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Convert a single-signature account to a multi-signature account or vice versa.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/hypercore/multi-sig
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * // Convert to multi-sig user
     * await multiSignClient.convertToMultiSigUser({
     *   authorizedUsers: ["0x...", "0x...", "0x..."],
     *   threshold: 2,
     * });
     *
     * // Convert to single-sig user
     * await multiSignClient.convertToMultiSigUser(null);
     * ```
     */
    async convertToMultiSigUser(...[args, signal]) {
        // Destructure the parameters
        const actionArgs = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.convertToMultiSigUser({
            type: "convertToMultiSigUser",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            signers: JSON.stringify(actionArgs),
            nonce,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Create a sub-account.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Response for creating a sub-account.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.createSubAccount({ name: "..." });
     * ```
     */
    async createSubAccount(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.createSubAccount({ type: "createSubAccount", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Create a vault.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Response for creating a vault.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.createVault({ name: "...", description: "...", initialUsd: 100 * 1e6 });
     * ```
     */
    async createVault(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.createVault({ type: "createVault", nonce, ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Jail or unjail self as a validator signer.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * // Jail self
     * await multiSignClient.cSignerAction({ jailSelf: null });
     *
     * // Unjail self
     * await multiSignClient.cSignerAction({ unjailSelf: null });
     * ```
     */
    async cSignerAction(...[args, signal]) {
        // Destructure the parameters
        const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.CSignerAction({ type: "CSignerAction", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            expiresAfter,
        }, signal);
    }
    /**
     * Action related to validator management.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * // Change validator profile
     * await multiSignClient.cValidatorAction({
     *   changeProfile: {
     *     name: "...",
     *     description: "...",
     *     unjailed: true,
     *   }
     * });
     *
     * // Register a new validator
     * await multiSignClient.cValidatorAction({
     *   register: {
     *     profile: {
     *       node_ip: { Ip: "1.2.3.4" },
     *       name: "...",
     *       description: "...",
     *       delegations_disabled: true,
     *       commission_bps: 1,
     *       signer: "0x...",
     *     },
     *     unjailed: false,
     *     initial_wei: 1,
     *   },
     * });
     *
     * // Unregister a validator
     * await multiSignClient.cValidatorAction({ unregister: null });
     * ```
     */
    async cValidatorAction(...[args, signal]) {
        // Destructure the parameters
        const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.CValidatorAction({ type: "CValidatorAction", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            expiresAfter,
        }, signal);
    }
    /**
     * Transfer native token from staking into the user's spot account.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#withdraw-from-staking
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.cWithdraw({ wei: 1 * 1e8 });
     * ```
     */
    async cWithdraw(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.cWithdraw({
            type: "cWithdraw",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Configure block type for EVM transactions.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Response for creating a sub-account.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/evm/dual-block-architecture
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.evmUserModify({ usingBigBlocks: true });
     * ```
     */
    async evmUserModify(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.evmUserModify({ type: "evmUserModify", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Modify an order.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-an-order
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.modify({
     *   oid: 123,
     *   order: {
     *     a: 0,
     *     b: true,
     *     p: "31000",
     *     s: "0.2",
     *     r: false,
     *     t: { limit: { tif: "Gtc" } },
     *     c: "0x...",
     *   },
     * });
     * ```
     */
    async modify(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.modify({ type: "modify", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * @multisign Not implemented
     */
    multiSig(...[_args, _signal]) {
        throw new Error("Not implemented"); // FIXME
    }
    /**
     * Place an order(s).
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful variant of {@link OrderResponse} without error statuses.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.order({
     *   orders: [
     *     {
     *       a: 0,
     *       b: true,
     *       p: "30000",
     *       s: "0.1",
     *       r: false,
     *       t: { limit: { tif: "Gtc" } },
     *       c: "0x...",
     *     },
     *   ],
     *   grouping: "na",
     * });
     * ```
     */
    async order(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.order({ type: "order", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Deploying HIP-3 assets.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/deploying-hip-3-assets
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.perpDeploy({
     *   registerAsset: {
     *     maxGas: 1000000,
     *     assetRequest: {
     *       coin: "USDC",
     *       szDecimals: 8,
     *       oraclePx: "1",
     *       marginTableId: 1,
     *       onlyIsolated: false,
     *     },
     *     dex: "test",
     *   },
     * });
     * ```
     */
    async perpDeploy(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.perpDeploy({ type: "perpDeploy", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Transfer funds between Spot account and Perp dex account.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#transfer-from-spot-account-to-perp-account-and-vice-versa
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.perpDexClassTransfer({ dex: "test", token: "USDC", amount: "1", toPerp: true });
     * ```
     */
    async perpDexClassTransfer(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.PerpDexClassTransfer({
            type: "PerpDexClassTransfer",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Create a referral code.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.registerReferrer({ code: "..." });
     * ```
     */
    async registerReferrer(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.registerReferrer({ type: "registerReferrer", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Reserve additional rate-limited actions for a fee.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#reserve-additional-actions
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.reserveRequestWeight({ weight: 10 });
     * ```
     */
    async reserveRequestWeight(...[args, signal]) {
        // Destructure the parameters
        const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.reserveRequestWeight({ type: "reserveRequestWeight", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            expiresAfter,
        }, signal);
    }
    async scheduleCancel(args_or_signal, maybeSignal) {
        const args = args_or_signal instanceof AbortSignal ? {} : args_or_signal ?? {};
        const signal = args_or_signal instanceof AbortSignal ? args_or_signal : maybeSignal;
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.scheduleCancel({ type: "scheduleCancel", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Set the display name in the leaderboard.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.setDisplayName({ displayName: "..." });
     * ```
     */
    async setDisplayName(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.setDisplayName({ type: "setDisplayName", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Set a referral code.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.setReferrer({ code: "..." });
     * ```
     */
    async setReferrer(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.setReferrer({ type: "setReferrer", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Deploying HIP-1 and HIP-2 assets.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/deploying-hip-1-and-hip-2-assets
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.spotDeploy({
     *   registerToken2: {
     *     spec: {
     *       name: "USDC",
     *       szDecimals: 8,
     *       weiDecimals: 8,
     *     },
     *     maxGas: 1000000,
     *     fullName: "USD Coin",
     *   },
     * });
     * ```
     */
    async spotDeploy(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.spotDeploy({ type: "spotDeploy", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Send spot assets to another address.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#core-spot-transfer
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.spotSend({
     *   destination: "0x...",
     *   token: "USDC:0xeb62eee3685fc4c43992febcd9e75443",
     *   amount: "1",
     * });
     * ```
     */
    async spotSend(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.spotSend({
            type: "spotSend",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            time: nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Opt Out of Spot Dusting.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.spotUser({ toggleSpotDusting: { optOut: false } });
     * ```
     */
    async spotUser(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.spotUser({ type: "spotUser", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Transfer between sub-accounts (spot).
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.subAccountSpotTransfer({
     *   subAccountUser: "0x...",
     *   isDeposit: true,
     *   token: "USDC:0xeb62eee3685fc4c43992febcd9e75443",
     *   amount: "1",
     * });
     * ```
     */
    async subAccountSpotTransfer(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.subAccountSpotTransfer({ type: "subAccountSpotTransfer", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Transfer between sub-accounts (perpetual).
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.subAccountTransfer({ subAccountUser: "0x...", isDeposit: true, usd: 1 * 1e6 });
     * ```
     */
    async subAccountTransfer(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.subAccountTransfer({ type: "subAccountTransfer", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Delegate or undelegate native tokens to or from a validator.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#delegate-or-undelegate-stake-from-validator
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.tokenDelegate({ validator: "0x...", isUndelegate: true, wei: 1 * 1e8 });
     * ```
     */
    async tokenDelegate(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.tokenDelegate({
            type: "tokenDelegate",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Cancel a TWAP order.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful variant of {@link TwapCancelResponse} without error status.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-a-twap-order
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.twapCancel({ a: 0, t: 1 });
     * ```
     */
    async twapCancel(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.twapCancel({ type: "twapCancel", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Place a TWAP order.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful variant of {@link TwapOrderResponse} without error status.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-a-twap-order
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * const data = await multiSignClient.twapOrder({
     *   a: 0,
     *   b: true,
     *   s: "1",
     *   r: false,
     *   m: 10,
     *   t: true,
     * });
     * ```
     */
    async twapOrder(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.twapOrder({ type: "twapOrder", twap: { ...actionArgs } });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Add or remove margin from isolated position.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.updateIsolatedMargin({ asset: 0, isBuy: true, ntli: 1 * 1e6 });
     * ```
     */
    async updateIsolatedMargin(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.updateIsolatedMargin({ type: "updateIsolatedMargin", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Update cross or isolated leverage on a coin.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-leverage
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.updateLeverage({ asset: 0, isCross: true, leverage: 5 });
     * ```
     */
    async updateLeverage(...[args, signal]) {
        // Destructure the parameters
        const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.updateLeverage({ type: "updateLeverage", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, vaultAddress, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            vaultAddress,
            expiresAfter,
        }, signal);
    }
    /**
     * Transfer funds between Spot account and Perp account.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#transfer-from-spot-account-to-perp-account-and-vice-versa
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.usdClassTransfer({ amount: "1", toPerp: true });
     * ```
     */
    async usdClassTransfer(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.usdClassTransfer({
            type: "usdClassTransfer",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Send usd to another address.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#core-usdc-transfer
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.usdSend({ destination: "0x...", amount: "1" });
     * ```
     */
    async usdSend(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.usdSend({
            type: "usdSend",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            time: nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Distribute funds from a vault between followers.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.vaultDistribute({ vaultAddress: "0x...", usd: 10 * 1e6 });
     * ```
     */
    async vaultDistribute(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.vaultDistribute({ type: "vaultDistribute", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Modify a vault's configuration.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see null
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.vaultModify({
     *   vaultAddress: "0x...",
     *   allowDeposits: true,
     *   alwaysCloseOnWithdraw: false,
     * });
     * ```
     */
    async vaultModify(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.vaultModify({ type: "vaultModify", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /**
     * Deposit or withdraw from a vault.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#deposit-or-withdraw-from-a-vault
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.vaultTransfer({ vaultAddress: "0x...", isDeposit: true, usd: 10 * 1e6 });
     * ```
     */
    async vaultTransfer(...[args, signal]) {
        // Destructure the parameters
        const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.vaultTransfer({ type: "vaultTransfer", ...actionArgs });
        // Send a multi-sig action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignL1Action({ action, nonce, outerSigner, expiresAfter });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
            expiresAfter,
        }, signal);
    }
    /**
     * Initiate a withdrawal request.
     * @param args - The parameters for the request.
     * @param signal - An optional abort signal.
     * @returns Successful response without specific data.
     *
     * @throws {ApiRequestError} When the API returns an unsuccessful response.
     * @throws {TransportError} When the transport layer throws an error.
     *
     * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#initiate-a-withdrawal-request
     * @example
     * ```ts
     * import * as hl from "@nktkas/hyperliquid";
     *
     * const multiSignAddress = "0x...";
     * const signers = [
     *   "0x...", // Private key; or any other wallet libraries
     * ] as const;
     *
     * const transport = new hl.HttpTransport(); // or `WebSocketTransport`
     * const multiSignClient = new hl.MultiSignClient({ transport, multiSignAddress, signers });
     *
     * await multiSignClient.withdraw3({ destination: "0x...", amount: "1" });
     * ```
     */
    async withdraw3(...[args, signal]) {
        // Destructure the parameters
        const { ...actionArgs } = args;
        // Construct an action
        const nonce = await this.nonceManager();
        const action = actionSorter.withdraw3({
            type: "withdraw3",
            hyperliquidChain: this._getHyperliquidChain(),
            signatureChainId: await this._getSignatureChainId(),
            time: nonce,
            ...actionArgs,
        });
        // Sign the action
        const outerSigner = await this._getWalletAddress(this.signers[0]);
        const signatures = await this._multiSignUserSignedAction({ action, outerSigner });
        // Send a multi-sig action
        return super.multiSig({
            signatures,
            payload: {
                multiSigUser: this.multiSignAddress,
                outerSigner,
                action,
            },
            nonce,
        }, signal);
    }
    /** Extracts the wallet address from different wallet types. */
    async _getWalletAddress(wallet) {
        if (isValidPrivateKey(wallet)) {
            return privateKeyToAddress(wallet);
        }
        else if (isAbstractViemWalletClient(wallet)) {
            return wallet.address;
        }
        else if (isAbstractEthersSigner(wallet) || isAbstractEthersV5Signer(wallet)) {
            return await wallet.getAddress();
        }
        else if (isAbstractWindowEthereum(wallet)) {
            const accounts = await wallet.request({ method: "eth_requestAccounts", params: [] });
            if (!Array.isArray(accounts) || accounts.length === 0) {
                throw new Error("No Ethereum accounts available");
            }
            return accounts[0];
        }
        else {
            throw new Error("Unsupported wallet for getting address");
        }
    }
    /** Signs L1 action with all signers for multi-signature operations. */
    _multiSignL1Action(args) {
        const { action, nonce, outerSigner, vaultAddress, expiresAfter } = args;
        return Promise.all(this.signers.map((signer) => {
            return signL1Action({
                wallet: signer,
                action: [this.multiSignAddress.toLowerCase(), outerSigner.toLowerCase(), action],
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
        }));
    }
    /** Signs user-signed action with all signers for multi-signature operations. */
    _multiSignUserSignedAction(args) {
        const { action, outerSigner } = args;
        return Promise.all(this.signers.map((signer) => {
            const types = structuredClone(userSignedActionEip712Types[action.type]); // for safe mutation
            Object.values(types)[0].splice(// array mutation
            1, // after `hyperliquidChain`
            0, // do not remove any elements
            { name: "payloadMultiSigUser", type: "address" }, { name: "outerSigner", type: "address" });
            return signUserSignedAction({
                wallet: signer,
                action: {
                    payloadMultiSigUser: this.multiSignAddress,
                    outerSigner,
                    ...action,
                },
                types,
            });
        }));
    }
}
/** Converts a private key to an Ethereum address. */
function privateKeyToAddress(privateKey) {
    const cleanPrivKey = privateKey.startsWith("0x") ? privateKey.slice(2) : privateKey;
    const publicKey = getPublicKey(cleanPrivKey, false);
    const publicKeyWithoutPrefix = publicKey.slice(1);
    const hash = keccak_256(publicKeyWithoutPrefix);
    const addressBytes = hash.slice(-20);
    const address = etc.bytesToHex(addressBytes);
    return `0x${address}`;
}
